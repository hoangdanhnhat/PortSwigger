# Exploiting unrestricted file uploads to deploy a web shell

**The following PHP one-liner could be used to read arbitrary files from the server's filesystem:**

```php
<?php echo file_get_contents('/path/to/target/file'); ?>
```

Once uploaded, sending a request for this malicious file will return the target file's contents in the response.

**A more versatile web shell may look something like this:**

```php
<?php echo system($_GET['command']); ?>
```

This script enables you to pass an arbitrary system command via a query parameter as follows:

```
GET /example/exploit.php?command=id HTTP/1.1
```

# Exploiting flawed validation of file uploads

One way that websites may attempt to validate file uploads is to check that this input-specific Content-Type header matches an expected MIME type. If the server is only expecting image files, for example, it may only allow types like **image/jpeg** and **image/png**. Problems can arise when the value of this header is implicitly trusted by the server. If no further validation is performed to check whether the contents of the file actually match the supposed MIME type, this defense can be easily bypassed using tools like Burp Repeater.

# Preventing file execution in user-accessible directories

While it's clearly better to prevent dangerous file types being uploaded in the first place, the second line of defense is to stop the server from executing any scripts that do slip through the net.

As a precaution, servers generally only run scripts whose MIME type they have been explicitly configured to execute. Otherwise, they may just return some kind of error message or, in some cases, serve the contents of the file as plain text instead

## Tip

Web servers often use the filename field in multipart/form-data requests to determine the name and location where the file should be saved.

In the Content-Disposition header, change the filename to include a directory traversal sequence:

```
Content-Disposition: form-data; name="avatar"; filename="../exploit.php"
```

## Some time the server strip the directory traversal sequence from the file name

Then we need to obfuscate the directory traversal sequence by URL encoding the forward slash (/) character, resulting in:

```
filename="..%2fexploit.php"
```

# Insufficient blacklisting of dangerous file types

One of the more obvious ways of preventing users from uploading malicious scripts is to blacklist potentially dangerous file extensions like .php. The practice of blacklisting is inherently flawed as it's difficult to explicitly block every possible file extension that could be used to execute code. Such blacklists can sometimes be bypassed by using lesser known, alternative file extensions that may still be executable, such as .php5, .shtml, and so on.

## Overriding the server configuration

